<link rel="import" href="../../../../bower_components/polymer/polymer.html">

<link rel="import" href="../../../../bower_components/paper-card/paper-card.html">
<link rel="import" href="../../../../bower_components/paper-item/paper-item.html">
<link rel="import" href="../../../../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../../../../bower_components/paper-styles/shadow.html">
<link rel="import" href="../../../../bower_components/paper-input/paper-input.html">
<link rel="import" href="../../../../bower_components/paper-input/paper-input-container.html">
<link rel="import" href="../../../../bower_components/paper-input/paper-textarea.html">
<link rel="import" href="../../../../bower_components/paper-tooltip/paper-tooltip.html">
<link rel="import" href="../../../../bower_components/paper-dialog/paper-dialog.html">

<link rel="import" href="../../../../bower_components/iron-icon/iron-icon.html">
<link rel="import" href="../../../../bower_components/iron-icons/hardware-icons.html">
<link rel="import" href="../../../../bower_components/iron-icons/image-icons.html">
<link rel="import" href="../../../../bower_components/iron-icons/editor-icons.html">

<link rel="import" href="../../../../bower_components/iron-meta/iron-meta.html">
<link rel="import" href="../../../../bower_components/iron-input/iron-input.html">
<link rel="import" href="../../../../bower_components/iron-iconset/iron-iconset.html">
<link rel="import" href="../../../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../../../bower_components/iron-iconset-svg/iron-iconset-svg.html">

<link rel="import" href="../../../../bower_components/vaadin-icons/vaadin-icons.html">
<link rel="import" href="../../../../bower_components/vaadin-upload/vaadin-upload.html">
<link rel="import" href="../../../../bower_components/vaadin-checkbox/vaadin-checkbox.html">

<link rel="import" href="../../dynamic-form/dynamically-loaded-form.html">
<link rel="import" href="../../dynamic-form/entity-selector.html">

<link rel="import" href="../../ht-spinner/ht-spinner.html">

<link rel="import" href="../../../styles/scrollbar-style.html">
<link rel="import" href="../../../styles/buttons-style.html">
<link rel="import" href="../../../styles/dialog-style.html">
<link rel="import" href="../../../styles/vaadin-icure-theme.html">
<link rel="import" href="../../../styles/shared-styles.html">
<link rel="import" href="../../../styles/dropdown-style.html">
<link rel="import" href="../../../styles/paper-tabs-style.html">





<dom-module id="ht-pat-outgoing-document">



    <template>



        <style include="scrollbar-style dialog-style buttons-style dropdown-style paper-tabs-style shared-styles">

            #outgoingDocumentDialog {
                height:100%;
                min-width: 70%;
            }

            .overlaySpinnerContainer {
                position:absolute;
                width:100%;
                height:100%;
                z-index:10;
                background:rgba(255, 255, 255, .8);
                top:0;
                left:0;
                margin:0;
                padding:0;
            }

            .overlaySpinner {
                max-width:80px;
                margin:100px auto
            }

        </style>





        <paper-dialog id="outgoingDocumentDialog" class="mt60" always-on-top="true" no-cancel-on-outside-click="true" no-cancel-on-esc-key="true">

            <h2 class="modal-title">[[localize('new_out-doc','New outgoing document',language)]]</h2>

            <div class="content">
                <prose-editor id="prose-editor" class="content" on-refresh-context="_refreshProseEditorContext"></prose-editor>
            </div>

            <div class="buttons">

                Gauche: charger modèle, sauver modèle, imrpimer<br />
                Droite: fermer, enregistrer et ajouter au dossier

                <paper-button class="button button--other" dialog-dismiss><iron-icon icon="icons:close"></iron-icon> [[localize('can','Cancel',language)]]</paper-button>
                <paper-button class="button button--save" on-tap="_archiveBatch"><iron-icon icon="check-circle"></iron-icon> [[localize('confirm','Confirm',language)]]</paper-button>



<!--                Lettre de liaison:-->
<!--                <paper-button class="button" on-tap="_closeLinkingLetterDialog"><iron-icon icon="icons:close" class="mr5 smallIcon" ></iron-icon> [[localize('clo','Close',language)]]</paper-button>-->
<!--                <paper-button class="button button&#45;&#45;other" on-tap="_printLinkingLetter"><iron-icon icon="icons:print" class="mr5 smallIcon" ></iron-icon> [[localize('print','Print',language)]]</paper-button>-->
<!--                <paper-button class="button button&#45;&#45;save" autofocus on-tap="_saveLinkingLetter"><iron-icon icon="icons:save" class="mr5 smallIcon" ></iron-icon> [[localize('saveToPatFile','Save to patient file',language)]]</paper-button>                -->



<!--                Documents sortants:-->
<!--                <paper-button class="button button&#45;&#45;other" on-tap="_openTemplateDescriptionDialog">[[localize('sav_mod','Save model',language)]]</paper-button>-->
<!--                <paper-button class="button button&#45;&#45;other" on-tap="loadTemplate">[[localize('load_mod','Load model',language)]]</paper-button>-->
<!--                <paper-button class="button button&#45;&#45;other" on-tap="printDocument">[[localize('print','Print',language)]]</paper-button>-->
<!--                <paper-button class="button" dialog-dismiss>[[localize('can','Cancel',language)]]</paper-button>-->
<!--                <paper-button class="button button&#45;&#45;save" dialog-confirm autofocus on-tap="_saveReport">[[localize('save','Save',language)]]</paper-button>-->

            </div>





            <template is="dom-if" if="[[_isBusy]]"><div class="overlaySpinnerContainer"><div class="overlaySpinner"><ht-spinner active></ht-spinner></div></div></template>

        </paper-dialog>





    </template>



    <script>



        import _ from 'lodash/lodash';
        import moment from 'moment/src/moment';
        import '../../prose-editor/prose-editor/prose-editor';
        import * as evaljs from "evaljs";
        import * as models from 'icc-api/dist/icc-api/model/models';



        class HtPatOutgoingDocument extends Polymer.TkLocalizerMixin(Polymer.Element) {

            static get is() {
                return 'ht-pat-outgoing-document';
            }

            static get properties() {
                return {
                    api: {
                        type: Object,
                        noReset: true,
                        value: () => {}
                    },
                    user: {
                        type: Object,
                        noReset: true,
                        value: () => {}
                    },
                    i18n: {
                        type: Object,
                        noReset: true,
                        value: () => {}
                    },
                    resources: {
                        type: Object,
                        noReset: true,
                        value: () => {}
                    },
                    language: {
                        type: String,
                        noReset: true,
                        value: "fr"
                    },
                    patient: {
                        type: Object,
                        noReset: true,
                        value: () => {}
                    },
                    _isBusy: {
                        type: Boolean,
                        value: false,
                        noReset: true
                    },
                    dataProvider: {
                        type: Object,
                        value: () => {}
                    },
                    _data: {
                        type: Object,
                        value: () => {return{
                            currentHcp: {
                                type: Object,
                                value: () => {}
                            },
                            currentPatient: {
                                type: Object,
                                value: () => {}
                            },
                            codes: {
                                type: Object,
                                value: ()=>{}
                            },
                            contact: {
                                type: Object,
                                value: ()=>{}
                            },
                            proseEditorVariables: {
                                type: Array,
                                value: () => []
                            }
                        }}
                    }
                };
            }

            static get observers() {
                return [];
            }

            constructor() {
                super();
            }

            ready() {
                super.ready();
            }

            _resetComponentProperties() {
                const promResolve = Promise.resolve();
                return promResolve
                    .then(() => {
                        const componentProperties = HtPatOutgoingDocument.properties
                        Object.keys(componentProperties).forEach(k => { if (!_.get(componentProperties[k],"noReset", false)) { this.set(k, (typeof componentProperties[k].value === 'function' ? componentProperties[k].value() : (componentProperties[k].value || null))) }})
                        return promResolve
                    })
            }

            _msTstampToDDMMYYYY(msTstamp) {
                return parseInt(msTstamp) ? this.api.moment(parseInt(msTstamp)).format('DD/MM/YYYY') : ""
            }

            _msTstampToYYYYMMDD(msTstamp) {
                return parseInt(msTstamp) ? this.api.moment(parseInt(msTstamp)).format('YYYYMMDD') : ""
            }

            _YYYYMMDDToDDMMYYYY(inputValue) {
                return parseInt(inputValue) ? this.api.moment(_.trim(parseInt(inputValue)),"YYYYMMDD").format('DD/MM/YYYY') : ""
            }

            _YYYYMMDDHHmmssToDDMMYYYYHHmmss(inputValue) {
                return parseInt(inputValue) ? this.api.moment(_.trim(parseInt(inputValue)),"YYYYMMDDHHmmss").format('DD/MM/YYYY HH:mm:ss') : ""
            }

            _upperFirstAll(inputValue){
                return _.trim(_.map(_.trim(inputValue).toLowerCase().split(" "),i=>_.upperFirst(_.trim(i))).join(" "))
            }

            _dobToAge(inputValue) {
                return inputValue ? this.api.getCurrentAgeFromBirthDate(inputValue,( e , s ) => this.localize(e, s, this.language)) : ''
            }

            _getServiceShortDescription(svc) {
                return this.api.contact().shortServiceDescription(svc, this.language);
            }

            _getServicesOfContacts(contacts) {

                return _.filter(
                    _.sortBy(
                        _.compact(_.flatMap(contacts, c => {
                            const labOrProtocolSubContacts = _.filter(_.get(c,"subContacts",[]),sctc => !!((parseInt(_.get(sctc, "status", 0)) & (1 << 0)) || (parseInt(_.get(sctc, "status", 0)) & (1 << 5))))
                            const labOrProtocolSubContactsServices = _.compact(_.flatMap(labOrProtocolSubContacts, it => _.map(_.get(it,"services",[]), svc => _.trim(_.get(svc,"serviceId","")) )))
                            return (!!parseInt(_.get(c,"endOfLife",0)) || !!parseInt(_.get(c,"deletionDate",0))) ? false :  _.compact(_.map(_.get(c,"services",{}), svc => !!parseInt(_.get(svc,"endOfLife",0)) || labOrProtocolSubContactsServices.indexOf(_.trim(_.get(svc,"id",""))) === -1 ? false : svc))
                        })),

                        ["modified","index"],["asc","asc"]
                    ),
                    svc => true /* !!_.trim(this._getServiceShortDescription(svc)) */
                )

            }

            _getServiceNormalValues(svc) {
                const c = this.api.contact().preferredContent(svc, this.language)
                return c && c.measureValue && `${c.measureValue.ref ? c.measureValue.ref.toFixed(2) : ''} ${c.measureValue.min || c.measureValue.max ? `${c.measureValue.min ? c.measureValue.min.toFixed(1) : '*'} - ${c.measureValue.max ? c.measureValue.max.toFixed(1) : '*'}` : ''}` || '';
            }

            _getServicesMap(singleContact) {
                return singleContact.reduce((map, ctc) => {
                    const svcMap = ctc.subContacts.reduce((svcMap, subContact) => { subContact.services.reduce((svcMap, svcLink) => { (svcMap[svcLink.serviceId] || (svcMap[svcLink.serviceId] = [])).push(subContact); return svcMap; }, svcMap); return svcMap; }, {});
                    ctc.services.reduce((map, svc) => { (map[svc.label] || (map[svc.label] = [])).push({ svc: svc, scs: svcMap[svc.id] || [], ctc: ctc }); return map; }, map);
                    Object.values(map).forEach(arr => arr.sort((a, b) => b.svc.modified - a.svc.modified));
                    return map;
                }, {})
            }

            _getPrettifiedHcp() {

                const promResolve = Promise.resolve()

                return this.api.hcparty().getCurrentHealthcareParty()
                    .then(hcp => {
                        const addressData = _.find(_.get(hcp,"addresses",[]), {addressType:"work"}) || _.find(_.get(hcp,"addresses",[]), {addressType:"home"}) || _.get(hcp,"addresses[0]",[])
                        return _.merge({}, hcp, _.mapValues({
                            address: [ _.trim(_.get(addressData,"street","")), _.trim(_.get(addressData,"houseNumber","")) + (!!_.trim(_.get(addressData,"postboxNumber","")) ? "/" + _.trim(_.get(addressData,"postboxNumber","")) : "") ].join(", "),
                            postalCode: _.trim(_.get(addressData,"postalCode","")),
                            city: this._upperFirstAll(_.trim(_.get(addressData,"city",""))),
                            country: this._upperFirstAll(_.trim(_.get(addressData,"country",""))),
                            phone: _.trim(_.get(_.find(_.get(addressData,"telecoms",[]), {"telecomType":"phone"}), "telecomNumber", "")),
                            mobile: _.trim(_.get(_.find(_.get(addressData,"telecoms",[]), {"telecomType":"mobile"}), "telecomNumber", "")),
                            email: _.trim(_.get(_.find(_.get(addressData,"telecoms",[]), {"telecomType":"email"}), "telecomNumber", "")),
                            firstName: this._upperFirstAll(_.get(hcp,"firstName","")),
                            lastName: this._upperFirstAll(_.get(hcp,"lastName","")),
                            nihiiHr: this.api.formatInamiNumber(_.trim(_.get(hcp,"nihii",""))),
                            ssinHr: this.api.formatSsinNumber(_.trim(_.get(hcp,"ssin",""))),
                        }, i => typeof i === "string" ? !!_.trim(i) ? _.trim(i) : '-' : i))
                    })
                    .catch(()=>promResolve)

            }

            _getPrettifiedPatient(user, patientId, patientObject=null) {

                const promResolve = Promise.resolve()

                return !_.size(patientObject) && (!_.trim(_.get(user, "id")) || !_.trim(patientId)) ? promResolve : (!!_.size(patientObject) ? Promise.resolve(patientObject) : this.api.patient().getPatientWithUser(user, patientId))
                    .then(patient => {
                        const addressData = _.find(_.get(patient,"addresses",[]), {addressType:"home"}) || _.find(_.get(patient,"addresses",[]), {addressType:"work"}) || _.get(patient,"addresses[0]",[])
                        return _.merge({}, patient, _.mapValues({
                            address: [ _.trim(_.get(addressData,"street","")), _.trim(_.get(addressData,"houseNumber","")) + (!!_.trim(_.get(addressData,"postboxNumber","")) ? "/" + _.trim(_.get(addressData,"postboxNumber","")) : "") ].join(", "),
                            postalCode: _.trim(_.get(addressData,"postalCode","")),
                            city: this._upperFirstAll(_.trim(_.get(addressData,"city",""))),
                            country: this._upperFirstAll(_.trim(_.get(addressData,"country",""))),
                            phone: _.trim(_.get(_.find(_.get(addressData,"telecoms",[]), {"telecomType":"phone"}), "telecomNumber", "")),
                            mobile: _.trim(_.get(_.find(_.get(addressData,"telecoms",[]), {"telecomType":"mobile"}), "telecomNumber", "")),
                            email: _.trim(_.get(_.find(_.get(addressData,"telecoms",[]), {"telecomType":"email"}), "telecomNumber", "")),
                            firstName: this._upperFirstAll(_.get(patient,"firstName","")),
                            lastName: this._upperFirstAll(_.get(patient,"lastName","")),
                            ssinHr: this.api.formatSsinNumber(_.trim(_.get(patient, "ssin", ""))),
                            gender: _.trim(_.get(patient, "gender", "male")),
                            genderHr: this._upperFirstAll(this.localize(_.trim(_.get(patient, "gender", "male")) + "GenderLong", "masculin")),
                            dateOfBirthHr: this._YYYYMMDDToDDMMYYYY(_.trim(_.get(patient, "dateOfBirth"))),
                            insuranceData: _
                                .chain(_.get(patient, "insurabilities",{}))
                                .filter((i)=>{
                                    return i &&
                                        !!moment( _.trim(_.get(i, "startDate", "0") ), "YYYYMMDD" ).isBefore(moment()) &&
                                        (!!moment( _.trim(_.get(i, "endDate", "0") ), "YYYYMMDD" ).isAfter(moment()) || !_.trim(_.get(i, "endDate", "") ) ) &&
                                        !!_.trim( _.get( i, "insuranceId", "" ) )
                                })
                                .map(i => {return _.mapValues({
                                    insuranceId: _.trim(_.get(i,"insuranceId","")),
                                    identificationNumber: _.trim(_.get(i,"identificationNumber","")),
                                    tc1: _.trim(_.get(i,"parameters.tc1","")),
                                    tc2: _.trim(_.get(i,"parameters.tc2","")),
                                    tc1tc2: [_.trim(_.get(i,"parameters.tc1","")), _.trim(_.get(i,"parameters.tc2",""))].join(" - "),
                                    preferentialstatus: typeof _.get(i,"parameters.preferentialstatus") === "boolean" ? !!_.get(i,"parameters.preferentialstatus",false) : _.trim(_.get(i,"parameters.preferentialstatus")) === "true"
                                }, i => typeof i === "string" ? !!_.trim(i) ? _.trim(i) : '-' : i)})
                                .head()
                                .value(),
                        }, i => typeof i === "string" ? !!_.trim(i) ? _.trim(i) : '-' : i))
                    })
                    .then(patient => this._getInsuranceData(_.trim(_.get(patient,"insuranceData.insuranceId"))).then(insuranceData => _.merge({},patient,{insuranceData:insuranceData})))
                    .catch(()=>promResolve)

            }

            _getInsuranceData(insuranceId) {

                const promResolve = Promise.resolve()

                return !_.trim(insuranceId) ? promResolve : this.api.insurance().getInsurance(insuranceId)
                    .then(insuranceData => _.merge({}, {
                        code: _.trim(_.get(insuranceData, "code", "")),
                        name: this._upperFirstAll(!!_.trim(_.get(insuranceData, "name." + this.language, "")) ? _.trim(_.get(insuranceData, "name." + this.language, "")) : _.trim(_.find(_.get(insuranceData, "name", {}), _.trim)))
                    }))
                    .catch(()=>promResolve)

            }

            _getCodesByType(codeType) {

                const promResolve = Promise.resolve()

                return !_.trim(codeType) ? promResolve : this.api.code().findPaginatedCodes("be", codeType)
                    .then(({rows}) => _
                        .chain(rows)
                        .filter(i=> !_.get(i,"disabled",false))
                        .map(i => _.merge({},i,{
                            labelHr: codeType === "CD-TRANSACTION" ?
                                _.upperFirst(_.trim(this.localize("cd-transaction-" + _.trim(_.get(i,"code")), _.trim(_.get(i,"code")), this.language)).toLowerCase()) :
                                _.trim(_.get(i,"label." + this.language,"")) ?
                                    _.upperFirst(_.trim(_.get(i,"label." + this.language,"")).toLowerCase()) :
                                    _.upperFirst(_.trim(_.head(_.flatMap(_.get(i,"label","")))).toLowerCase())
                        }))
                        .orderBy(["labelHr"],["asc"])
                        .value()
                    )
                    .then(codes => _.fromPairs([[codeType,codes]]))
                    .catch(()=>promResolve)

            }

            _getContact(user, contactId) {

                const promResolve = Promise.resolve()

                return !_.trim(_.get(user, "id")) || !_.trim(contactId) ? promResolve : this.api.contact().getContactWithUser(user, contactId)
                    .then(contact => _.merge(contact, {
                        createdHr: this._msTstampToDDMMYYYY(_.get(contact,"created","")),
                        openingDateHr: this._YYYYMMDDToDDMMYYYY(_.trim(_.get(contact,"openingDate","")).substring(0,8)),
                        openingDateYYYYMMDD: _.trim(_.get(contact,"openingDate","")).substring(0,8),
                        closingDateHr: this._YYYYMMDDToDDMMYYYY(_.trim(_.get(contact,"closingDate","")).substring(0,8)),
                    }))
                    .catch(()=>promResolve)

            }

            _isServiceOutOfRange(svc) {
                const c = this.api.contact().preferredContent(svc, this.language)
                return (c && c.measureValue && (c.measureValue.value < c.measureValue.min || c.measureValue.value > c.measureValue.max ))
            }

            _getServiceDate(svc) {
                return (svc && svc.modified) ? this.api.moment(svc.modified).format(svc.modified > 99991231 ? 'DD/MM/YYYY HH:mm' : 'DD/MM/YYYY') : '';
            }

            _getContentFromContact() {

                const promResolve = Promise.resolve()

                const user = _.get(this,"user",{})
                const contact = _.get(this,"_data.contact")
                const document = _.get(this,"_data.document",{})
                const patient = _.get(this,"_data.currentPatient")
                const sourceContactId = _.trim(_.get(contact,"id",""))
                const sourceContactGroupId = _.trim(_.get(contact,"groupId",""))

                return !sourceContactId ? promResolve : promResolve
                    .then(() => (!_.trim(_.get(user, "id")) || !_.size(patient)) ? Promise.resolve([contact]) : this.api.contact().findBy(_.trim(_.get(user,"healthcarePartyId","")), patient)
                        .then(contacts => (!sourceContactGroupId || _.size(contacts) === 1) ? contacts : _
                            .chain(contacts)
                            .filter(ctc => !!_.size(_.get(ctc, "services", [])) && _.trim(_.get(ctc,"groupId","")) === sourceContactGroupId)
                            .orderBy(["modified"], ["asc"])
                            .value()
                        )
                    )
                    .then(contacts => {

                        const servicesOfContacts = this._getServicesOfContacts(contacts)
                        const contactType = _.get(_.find(_.get(this,"_data.codes.CD-TRANSACTION",[]), {code:_.get(_.find(_.get(contact,"tags",[]),{type:"CD-TRANSACTION"}), "code","")}),"labelHr","")
                        const subContactType = _.get(_.find(_.get(this,"_data.codes.CD-TRANSACTION",[]), {code:_.get(_.find(_.flatMap(_.get(contact,"subContacts",[]),sctc => _.get(sctc,"tags",[])),{type:"CD-TRANSACTION"}), "code","")}),"labelHr","")
                        const targetSubContact = _.find(_.get(contact,"subContacts",[]), sctc => !!((parseInt(_.get(sctc, "status", 0)) & (1 << 0)) || (parseInt(_.get(sctc, "status", 0)) & (1 << 5))))

                        const documentServiceId = _.trim(_.get(_.find(_.get(contact,"subContacts",[]), sctc => !!((parseInt(_.get(sctc, "status", 0)) & (1 << 6)))),"services[0].serviceId",""))
                        const documentService = _.find(_.get(contact,"services",[]),{id:documentServiceId})
                        const documentType = _.get(_.find(_.get(this,"_data.codes.CD-TRANSACTION",[]), {code:_.trim(_.get(_.find(_.get(documentService,"tags",[]),{type:"CD-TRANSACTION"}), "code", ""))}),"labelHr","")
                        const documentTitle = _.trim(_.get(documentService,"content." + this.language + ".stringValue",""))

                        const contactOrDocumentType = !!_.trim(subContactType) ? _.trim(subContactType) : !!_.trim(contactType) ? _.trim(contactType) : _.trim(documentType)
                        const contactOrDocumentTitle = !!_.trim(_.get(contact,"descr","")) && !!_.trim(_.trim(_.get(contact,"descr","")).replace(contactOrDocumentType+":","")) ?
                            _.trim(_.get(contact,"descr","")).replace(contactOrDocumentType+":","") :
                            (!!_.trim(_.get(targetSubContact,"descr","")) || !!_.trim(_.get(targetSubContact,"protocol",""))) ? _.trim(_.get(targetSubContact,"descr","")) + (!!_.trim(_.get(targetSubContact,"protocol","")) ? " (" + this.localize("prot", "Protocol", this.language) + " #" + _.trim(_.get(targetSubContact,"protocol","")) + ")" : "" ) :
                                documentTitle

                        return {
                            dateHr: _.get(contact,"openingDateHr",""),
                            dateYYYYMMDD: _.get(contact,"openingDateYYYYMMDD",""),
                            title: contactOrDocumentTitle,
                            type: contactOrDocumentType,
                            fileExtension: _.trim(_.get(document, "attachment.fileExtension")).toLowerCase(),
                            mimeType: _.trim(_.get(document, "attachment.mimeType")).toLowerCase(),
                            downloadUrl: _.trim(_.get(document, "attachment.downloadUrl")),
                            body: !_.size(servicesOfContacts) && typeof _.get(document, "attachment.content") === "string" && !!_.trim(_.get(document, "attachment.content")) ? this._prettifyText(_.trim(_.get(document, "attachment.content"))) :
                                !_.size(servicesOfContacts) && _.get(document, "attachment.content") instanceof ArrayBuffer ? _.get(document, "attachment.content") :
                                    _.size(servicesOfContacts) === 1 ? this._prettifyText(this._getServiceShortDescription(_.head(servicesOfContacts))) :
                                        _.map(servicesOfContacts, svc => { return {
                                            isOutOfRange: !!this._isServiceOutOfRange(svc),
                                            label: _.trim(_.get(svc,"label","")),
                                            date: this._getServiceDate(svc),
                                            value: this._getServiceShortDescription(svc),
                                            normalValue: this._getServiceNormalValues(svc),
                                            author: this._getServiceAuthor(svc),
                                        }})
                        }

                    })

            }

            _refreshProseEditorContext() {

                return Promise.resolve(this._doApplyProseEditorContext(this.shadowRoot.querySelector("#prose-editor")));

            }


















            _doApplyProseEditorContext(proseEditorObject) {

                //This fn creates the function that return the subContexts (like the context but corresponding to a subForm)
                const makeSubContexts = (ctx) => ((key) =>
                    ctx.dataProvider.getSubForms(key).map(sf => {
                        const subCtx = _.assign({}, ctx, {dataProvider: sf.dataProvider})
                        subCtx.subContexts = makeSubContexts(subCtx)
                        return subCtx
                    })
                )

                const ctx = {
                    formatDate: (date) => this.api.moment(date).format('DD/MM/YYYY'),
                    user: _.get(this,"user",{}),
                    patient: _.get(this,"_data.currentPatient",{}),
                    hcp: _.get(this,"_data.currentHcp",{}),

                    contact: this.currentContact,
                    contacts: this.contacts,
                    healthElements: this.healthElements,
                    servicesMap: this.servicesMap,
                    language: this.language,
                    dataProvider: _.get(this,"dataProvider",{})
                }
                ctx.subContexts = makeSubContexts(ctx)

                proseEditorObject.applyContext((expr, ctx) => {
                    return new Promise(function (resolve, reject) {
                        try {
                            const env = new evaljs.Environment(_.assign(ctx, {resolve, reject}));
                            const gen = (env.gen(expr)())
                            let status = {done: false}
                            while (!status.done) { try { status = gen.next(); } catch (e) { reject(e); return; } }
                            if (status.value && status.value.asynchronous) {
                                //Wait for internal resolution... it is the responsibility of the js to call resolve
                                // TODO: manage some timeout
                            } else {
                                resolve(status.value)
                            }
                        } catch (e) { reject(e); }
                    })
                }, ctx)

            }




















            _getDataProvider() {

                return Promise.resolve({

                    getVariableValue: (value) => {
                        return _.trim(
                            value === "todaysDate" ? this.localize('day_' + parseInt(moment().day()), this.language) + ` ` + moment().format('DD') + ` `+ (this.localize('month_' + parseInt(moment().format('M')), this.language)).toLowerCase() + ` ` + moment().format('YYYY') :
                            ""
                        )
                    },

                    getLocalizedText: (value) => {
                        return this.localize(_.trim(value), "", this.language)
                    }

                })

            }


            _getProseEditorVariables() {

                return Promise.resolve([
                    {
                        type:'global',
                        name: this.localize('inv_prest', 'Healthcare party', this.language),
                        nodes: [
                            {type: 'paragraph', attrs: {}, content: [{type: 'text', marks: [{type: 'strong'}], text: this.localize('doctorAbreviation', 'Dr.', this.language) + ' '}, {type: 'variable', marks: [{type: 'strong'}], attrs: {expr: 'hcp.firstName'}}, {type: 'text', marks: [{type: 'strong'}], text: ' '}, {type: 'variable', marks: [{type: 'strong'}], attrs: {expr: 'hcp.lastName'}}]},
                            {type: 'paragraph',attrs: {},content: [{type: 'variable', attrs: {expr: 'hcp.address'}}]},
                            {type: 'paragraph', attrs: {}, content: [{type: 'variable', attrs: {expr: 'hcp.postalCode'}}, {type: 'text', marks: [{type: 'strong'}], text: ' '},{type: 'variable', attrs: {expr: 'hcp.city'}}] },
                            {type: 'paragraph',attrs: {}, content: [{type: 'text', text: "Tel: "}, {type: 'variable', attrs: {expr: 'hcp.phone'}}]},
                            {type: 'paragraph',attrs: {}, content: [{type: 'text', text: "E-mail: "}, {type: 'variable', attrs: {expr: 'hcp.email'}}]},
                            {type: 'paragraph',attrs: {}, content: [{type: 'text', text: _.trim(this.localize('inami', 'Nihii', this.language)).toUpperCase() + ': '}, {type: 'variable', attrs: {expr: 'hcp.nihiiHr'}}]},
                        ],
                        subVars: [
                            {name: this.localize('las_nam', 'Last name', this.language), nodes: [{type: 'variable', attrs: {expr: 'hcp.lastName'}}]},
                            {name: this.localize('fir_nam', 'First name', this.language), nodes: [{type: 'variable', attrs: {expr: 'hcp.firstName'}}]},
                            {name: this.localize('inami', 'Nihii', this.language), nodes: [{type: 'variable', attrs: {expr: 'hcp.nihiiHr'}}]}
                        ]
                    },{
                        type:'patientIdentification',
                        name:this.localize('idPatient', 'Patient identification', this.language),
                        nodes: [
                            {type: 'paragraph',attrs: {},content: [{type: 'text', marks: [{type: 'strong'}], text:_.trim(this.localize('idPatient', 'Patient identification', this.language)).toUpperCase()}]},
                            {type: 'table',attrs: {},content: [
                                {type: 'table_row',attrs: {},content: [
                                    {type: 'table_cell',attrs: { "colspan":1,"rowspan":1,"colwidth":null,"borderColor":null,"background":null},content: [
                                        {type:'paragraph',attrs: {},content: [
                                            {type: 'text', marks: [{type: 'strong'}], text: this.localize("lastAndAndFirstNames", "Last & first names", this.language) + ": "}, {type: 'variable', attrs: {expr: 'patient.lastName'}}, {type:'text', text: ' '}, {type: 'variable', attrs: {expr: 'patient.firstName'}},
                                            {type:'text', text: ' - '}, {type: 'text', marks: [{type: 'strong'}], text: this.localize("postalAddress", "Address", this.language) + ": "},
                                            {type: 'variable', attrs: {expr: 'patient.address'}}, {type:'text', text: ' - '}, {type: 'variable', attrs: {expr: 'patient.postalCode'}}, {type:'text', text: ' '}, {type: 'variable', attrs: {expr: 'patient.city'}},
                                        ]},
                                        {type:'paragraph',attrs: {},content: [
                                            {type: 'text', marks: [{type: 'strong'}], text: this.localize("sexLitteral", "Sex", this.language) + ": "}, {type: 'variable', attrs: {expr: 'patient.genderHr'}},
                                            {type:'text', text: ' - '}, {type: 'text', marks: [{type: 'strong'}], text: this.localize("birthDate", "Birthdate", this.language) + ": "}, {type: 'variable', attrs: {expr: 'patient.dateOfBirthHr'}},
                                            {type:'text', text: ' - '}, {type: 'text', marks: [{type: 'strong'}], text: this.localize("ssinPatVerbose", "NISS", this.language) + ": "}, {type: 'variable', attrs: {expr: 'patient.ssinHr'}},
                                        ]},
                                        {type:'paragraph',attrs: {},content: [
                                            {type:'text', marks: [{type: 'strong'}], text: "Email: "}, {type: 'variable', attrs: {expr: 'patient.email'}},
                                            {type:'text', text: ' '}, {type: 'text', marks: [{type: 'strong'}], text: this.localize("phone", "Phone", this.language) + ": "}, {type: 'variable', attrs: {expr: 'patient.phone'}},
                                            {type:'text', text: ' '}, {type: 'text', marks: [{type: 'strong'}], text: this.localize("ssinPatVerbose", "NISS", this.language) + ": "}, {type: 'variable', attrs: {expr: 'patient.ssinHr'}},
                                        ]},


                                        {type:'paragraph',attrs: {},content: [
                                            {type:'text', marks: [{type: 'strong'}], text: this.localize("adm_in", "Insurance", this.language) + ": "}, {type: 'variable', attrs: {expr: 'patient.insuranceData.name'}},
                                            {type:'text', text: ' (#'}, {type: 'variable', attrs: {expr: 'patient.insuranceData.code'}}, {type:'text', text: ') - '},
                                            {type:'text', marks: [{type: 'strong'}], text: this.localize("AFF", "Membership number", this.language) + ": "}, {type: 'variable', attrs: {expr: 'patient.insuranceData.identificationNumber'}},
                                            {type:'text', text: ' - '}, {type: 'text', marks: [{type: 'strong'}], text: "CT1 - CT2: "}, {type: 'variable', attrs: {expr: 'patient.insuranceData.tc1tc2'}},
                                        ]},


                                    ]}
                                ]}
                            ]},
                            {type: 'paragraph',attrs: {},content: [{type: 'text', text:" "}]},

                            // {type: 'paragraph',attrs: {},content: [{type: 'text', marks: [{type: 'strong'}], text: this.localize("lastAndAndFirstNames", "Last & first names", this.language) + ": "}, {type: 'variable', attrs: {expr: 'patient.lastName'}}, {type: 'text', marks: [{type: 'strong'}], text: ' '}, {type: 'variable', marks: [{type: 'strong'}], attrs: {expr: 'patient.firstName'}},]},
                            // {type: 'paragraph',attrs: {},content: [{type: 'text', marks: [{type: 'strong'}], text: this.localize("postalAddress", "Address", this.language) + ": "}, {type: 'variable', attrs: {expr: 'patient.address'}}]},
                            // {type: 'paragraph',attrs: {},content: [{type: 'text', marks: [{type: 'strong'}], text: this.localize("zipAndCity", "Zip & city", this.language) + ": "}, {type: 'variable', attrs: {expr: 'patient.postalCode'}}, {type: 'text', marks: [{type: 'strong'}], text: ' '},{type: 'variable', attrs: {expr: 'patient.city'}}]},
                            // {type: 'paragraph',attrs: {},content: [{type: 'text', marks: [{type: 'strong'}], text: this.localize("birthDate", "Birthdate", this.language) + ": "}, {type: 'variable', attrs: {expr: 'patient.dateOfBirthHr'}}]},
                            // {type: 'paragraph',attrs: {},content: [{type: 'text', marks: [{type: 'strong'}], text: this.localize("ssinPatVerbose", "NISS", this.language) + ": "}, {type: 'variable', attrs: {expr: 'patient.ssinHr'}}]},
                            // {type: 'paragraph',attrs: {},content: [{type: 'text', marks: [{type: 'strong'}], text: "E-mail: "}, {type: 'variable', attrs: {expr: 'patient.email'}}]},
                            // {type: 'paragraph',attrs: {},content: [{type: 'text', marks: [{type: 'strong'}], text: this.localize("phone", "Phone", this.language) + ": "}, {type: 'variable', attrs: {expr: 'patient.phone'}}]},
                            // {type: 'paragraph',attrs: {},content: [{type: 'text', marks: [{type: 'strong'}], text: this.localize("adm_in", "Insurance", this.language) + ": "}, {type: 'variable', attrs: {expr: 'patient.insuranceData.name'}}]},
                            // {type: 'paragraph',attrs: {},content: [{type: 'text', marks: [{type: 'strong'}], text: this.localize("insuranceCode", "Insurance code", this.language) + ": "}, {type: 'variable', attrs: {expr: 'patient.insuranceData.code'}}]},
                            // {type: 'paragraph',attrs: {},content: [{type: 'text', marks: [{type: 'strong'}], text: "CT1 - CT2: "}, {type: 'variable', attrs: {expr: 'patient.insuranceData.tc1tc2'}}]},
                            // {type: 'paragraph',attrs: {},content: [{type: 'text', marks: [{type: 'strong'}], text: this.localize("AFF", "Membership number", this.language) + ": "}, {type: 'variable', attrs: {expr: 'patient.insuranceData.identificationNumber'}}]},
                        ]
                    }, {
                        type:'patient',
                        name:this.localize('patientDetails', 'Patient details', this.language),
                        subVars: [
                            // Todo: injecter proprement / dynamicquement (avec translations) les valeurs qui on du sens
                            {name: this.localize('las_nam', 'Last name', this.language), nodes: [{type: 'variable', attrs: {expr: 'patient.lastName'}},{type:'text', text: ' '}]},
                            {name: this.localize('fir_nam', 'First name', this.language), nodes: [{type: 'variable', attrs: {expr: 'patient.firstName'}},{type:'text', text: ' '}]},
                            {name: this.localize('dat_of_bir', 'Date of birth', this.language), nodes: [{type: 'variable', attrs: {expr: 'patient.dateOfBirthHr)'}},{type:'text', text: ' '}]}
                        ]
                    }
                ]);

                const formVars = _.sortBy( _.map(e.detail.dataProvider.sortedItems().filter(i => i.type !== 'TKAction'), k => {
                    return {
                        type:'form',
                        name:k.label,
                        nodes: [
                            k.isSubForm ?
                                { type: 'template', attrs: { expr:`subContexts("${k.name}")`, template: {'default':[ { type: 'variable', attrs: { expr:`dataProvider.form().template.name`}}]} } } :
                                { type: 'variable', attrs: { expr:`const v = dataProvider.getValue("${k.name}"); Array.isArray(v) ? v.join(', ') : v`} }
                        ]
                    }
                }), "name" )

                return globalVars.concat(patientVars).concat(formVars);

            }











            open(inputData) {

                if(!!_.get(this,"_isBusy",false)) return;

                const promResolve = Promise.resolve()
                const patientId = !!_.trim(_.get(inputData,"patientId","")) ? _.trim(_.get(inputData,"patientId","")) : _.trim(_.get(this,"patient.id",""))

                // Make sure properties of component (that aren't set yet) actually are a variable rather than an object with a value key representing their value.
                _.map(_.get(this,"_data",{}), (propValue,propKey) => typeof _.get(propValue,"value",null) !== "function" ? null : this.set("_data." + propKey, _.get(propValue,"value",null)()))

                return this._resetComponentProperties()
                    .then(() => {
                        this.set("_isBusy", true)
                        this.shadowRoot.querySelector('#outgoingDocumentDialog').open()
                    })
                    .then(() => this._getPrettifiedHcp().then(hcp => _.assign(this._data, {currentHcp:hcp})))
                    .then(() => this._getPrettifiedPatient(_.get(this,"user",{}), patientId).then(patient => _.assign(this._data, {currentPatient:patient})))
                    .then(() => this._getProseEditorVariables().then(proseEditorVariables => _.assign(this._data, {proseEditorVariables:proseEditorVariables})))
                    .then(() => {
                        const proseEditor = this.shadowRoot.querySelector("#prose-editor")
                        proseEditor.set("dynamicVars", _.get(this,"_data.proseEditorVariables",[]))
                    })
                    .then(() => this._getDataProvider().then(dataProvider => _.assign(this, {dataProvider:dataProvider})))
                    .then(() => this._refreshProseEditorContext())
                    .catch(e => { console.log("[ERROR] outgoing document", e, inputData); return promResolve; })
                    .finally(() => {

                        console.log("inputData",inputData);
                        console.log("--- this._data ---",this._data);
                        console.log("--- this.dataProvider ---",this.dataProvider);

                        this.set("_isBusy", false)
                        return promResolve

                    })



                const contactId = _.trim(_.get(inputData,"contactId",""))

                return this._resetComponentProperties()
                    .then(() => this._getCodesByType("CD-TRANSACTION").then(codes => _.merge(this._data,{codes:codes})))
                    .then(() => this._getContact(_.get(this,"user",{}), contactId, _.get(this,"_data.currentPatient")).then(contact => _.assign(this._data,{contact:contact})))
                    .then(() => ((!_.size(_.get(this,"_data.document")) && !_.size(_.get(this,"_data.contact"))) ? promResolve : !!_.size(_.get(this,"_data.contact")) ? this._getContentFromContact() : promResolve).then(content => _.assign(this._data,{content:content})))
                    .then(() => _.assign(this._data,{pdfHtmlContent:this._getPdfContent()}))

                    //.then(() => this.api.pdfReport(this._data.pdfHtmlContent), {type:"rapp-mail",completionEvent:"pdfDoneRenderingEvent", printBackground:true})
                    // .then(printedPdf => !printedPdf.printed && this.api.triggerFileDownload( printedPdf.pdf, "application/pdf", _.kebabCase(_.trim(_.get(this,"_data.content.dateYYYYMMDD",moment().format("YYYYMMDD"))) + "-" + _.trim(_.get(this,"_data.content.title",this.api.crypto().randomUuid()))) + ".pdf" ))

            }







        }

        customElements.define(HtPatOutgoingDocument.is, HtPatOutgoingDocument);



    </script>



</dom-module>
