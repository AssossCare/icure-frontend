<link rel="import" href="../../../bower_components/polymer/polymer.html">

<!--<link rel="import" href="../dynamic-form/ht-services-list.html">-->
<!--<link rel="import" href="../dynamic-form/dynamic-doc.html">-->



<dom-module id="print-document">



    <script>



        import _ from 'lodash/lodash';
        import moment from 'moment/src/moment';
        import { Base64 } from 'js-base64';



        class PrintDocument extends Polymer.TkLocalizerMixin(Polymer.Element) {

            static get is() {
                return 'print-document';
            }

            static get properties() {
                return {
                    api: {
                        type: Object,
                        noReset: true,
                        value: () => {}
                    },
                    user: {
                        type: Object,
                        noReset: true,
                        value: () => {}
                    },
                    i18n: {
                        type: Object,
                        noReset: true,
                        value: () => {}
                    },
                    resources: {
                        type: Object,
                        noReset: true,
                        value: () => {}
                    },
                    language: {
                        type: String,
                        noReset: true,
                        value: "fr"
                    },
                    patient: {
                        type: Object,
                        noReset: true,
                        value: () => {}
                    },
                    _data: {
                        type: Object,
                        value: () => {return{
                            currentHcp: {
                                type: Object,
                                value: () => {}
                            },
                            currentPatient: {
                                type: Object,
                                value: () => {}
                            },
                            codes: {
                                type: Object,
                                value: ()=>{}
                            },
                            contact: {
                                type: Object,
                                value: ()=>{}
                            },
                            document: {
                                type: Object,
                                value: ()=>{}
                            },
                        }}
                    }
                };
            }

            static get observers() {
                return [];
            }

            constructor() {
                super();
            }

            ready() {
                super.ready();
            }

            _resetComponentProperties() {
                const promResolve = Promise.resolve();
                return promResolve
                    .then(() => {
                        const componentProperties = PrintDocument.properties
                        Object.keys(componentProperties).forEach(k => { if (!_.get(componentProperties[k],"noReset", false)) { this.set(k, (typeof componentProperties[k].value === 'function' ? componentProperties[k].value() : (componentProperties[k].value || null))) }})
                        return promResolve
                    })
            }

            _msTstampToDDMMYYYY(msTstamp) {
                return parseInt(msTstamp) ? this.api.moment(parseInt(msTstamp)).format('DD/MM/YYYY') : ""
            }

            _YYYYMMDDToDDMMYYYY(inputValue) {
                return parseInt(inputValue) ? this.api.moment(_.trim(parseInt(inputValue)),"YYYYMMDD").format('DD/MM/YYYY') : ""
            }

            _YYYYMMDDHHmmssToDDMMYYYYHHmmss(inputValue) {
                return parseInt(inputValue) ? this.api.moment(_.trim(parseInt(inputValue)),"YYYYMMDDHHmmss").format('DD/MM/YYYY HH:mm:ss') : ""
            }

            _upperFirstAll(inputValue){
                return _.trim(_.map(_.trim(inputValue).toLowerCase().split(" "),i=>_.upperFirst(_.trim(i))).join(" "))
            }

            _dobToAge(inputValue) {
                return inputValue ? this.api.getCurrentAgeFromBirthDate(inputValue,( e , s ) => this.localize(e, s, this.language)) : ''
            }

            _getServiceAuthor(svc) {
                return this.api.getAuthor(svc.author);
            }

            _getServiceShortDescription(svc) {
                return this.api.contact().shortServiceDescription(svc, this.language);
            }

            _prettifyText(input) {
                return _.trim(this._getServiceShortDescription(input)).replace(/\r\n|\n|\r/gm, "\n")
            }

            _getServicesOfContact(contact) {
                return _.sortBy(_.flatMap(contact, c => _.get(c,"services",{})), ['modified']);
            }

            _getServiceNormalValues(svc) {
                const c = this.api.contact().preferredContent(svc, this.language)
                return c && c.measureValue && `${c.measureValue.ref ? c.measureValue.ref.toFixed(2) : ''} ${c.measureValue.min || c.measureValue.max ? `${c.measureValue.min ? c.measureValue.min.toFixed(1) : '*'} - ${c.measureValue.max ? c.measureValue.max.toFixed(1) : '*'}` : ''}` || '';
            }

            _getServicesMap(singleContact) {
                return singleContact.reduce((map, ctc) => {
                    const svcMap = ctc.subContacts.reduce((svcMap, subContact) => { subContact.services.reduce((svcMap, svcLink) => { (svcMap[svcLink.serviceId] || (svcMap[svcLink.serviceId] = [])).push(subContact); return svcMap; }, svcMap); return svcMap; }, {});
                    ctc.services.reduce((map, svc) => { (map[svc.label] || (map[svc.label] = [])).push({ svc: svc, scs: svcMap[svc.id] || [], ctc: ctc }); return map; }, map);
                    Object.values(map).forEach(arr => arr.sort((a, b) => b.svc.modified - a.svc.modified));
                    return map;
                }, {})
            }

            _getPrettifiedHcp() {

                const promResolve = Promise.resolve()

                return this.api.hcparty().getCurrentHealthcareParty()
                    .then(hcp => {
                        const addressData = _.find(_.get(hcp,"addresses",[]), {addressType:"work"}) || _.find(_.get(hcp,"addresses",[]), {addressType:"home"}) || _.get(hcp,"addresses[0]",[])
                        return _.merge({}, hcp, {
                            address: [ _.trim(_.get(addressData,"street","")), _.trim(_.get(addressData,"houseNumber","")) + (!!_.trim(_.get(addressData,"postboxNumber","")) ? "/" + _.trim(_.get(addressData,"postboxNumber","")) : "") ].join(", "),
                            postalCode: _.trim(_.get(addressData,"postalCode","")),
                            city: this._upperFirstAll(_.trim(_.get(addressData,"city",""))),
                            country: this._upperFirstAll(_.trim(_.get(addressData,"country",""))),
                            phone: _.trim(_.get(_.find(_.get(addressData,"telecoms",[]), {"telecomType":"phone"}), "telecomNumber", "")),
                            mobile: _.trim(_.get(_.find(_.get(addressData,"telecoms",[]), {"telecomType":"mobile"}), "telecomNumber", "")),
                            email: _.trim(_.get(_.find(_.get(addressData,"telecoms",[]), {"telecomType":"email"}), "telecomNumber", "")),
                            firstName: this._upperFirstAll(_.get(hcp,"firstName","")),
                            lastName: this._upperFirstAll(_.get(hcp,"lastName","")),
                            nihiiHr: this.api.formatInamiNumber(_.trim(_.get(hcp,"nihii",""))),
                            ssinHr: this.api.formatSsinNumber(_.trim(_.get(hcp,"ssin",""))),
                        })
                    })
                    .catch(()=>promResolve)

            }

            _getPrettifiedPatient(user, patientId, patientObject=null) {

                const promResolve = Promise.resolve()

                return !_.size(patientObject) && (!_.trim(_.get(user, "id")) || !_.trim(patientId)) ? promResolve : (!!_.size(patientObject) ? Promise.resolve(patientObject) : this.api.patient().getPatientWithUser(user, patientId))
                    .then(patient => {
                        const addressData = _.find(_.get(patient,"addresses",[]), {addressType:"home"}) || _.find(_.get(patient,"addresses",[]), {addressType:"work"}) || _.get(patient,"addresses[0]",[])
                        return _.merge({}, patient, {
                            address: [ _.trim(_.get(addressData,"street","")), _.trim(_.get(addressData,"houseNumber","")) + (!!_.trim(_.get(addressData,"postboxNumber","")) ? "/" + _.trim(_.get(addressData,"postboxNumber","")) : "") ].join(", "),
                            postalCode: _.trim(_.get(addressData,"postalCode","")),
                            city: this._upperFirstAll(_.trim(_.get(addressData,"city",""))),
                            country: this._upperFirstAll(_.trim(_.get(addressData,"country",""))),
                            phone: _.trim(_.get(_.find(_.get(addressData,"telecoms",[]), {"telecomType":"phone"}), "telecomNumber", "")),
                            mobile: _.trim(_.get(_.find(_.get(addressData,"telecoms",[]), {"telecomType":"mobile"}), "telecomNumber", "")),
                            email: _.trim(_.get(_.find(_.get(addressData,"telecoms",[]), {"telecomType":"email"}), "telecomNumber", "")),
                            firstName: this._upperFirstAll(_.get(patient,"firstName","")),
                            lastName: this._upperFirstAll(_.get(patient,"lastName","")),
                            ssinHr: this.api.formatSsinNumber(_.trim(_.get(patient, "ssin", ""))),
                            gender: _.trim(_.get(patient, "gender", "male")),
                            genderHr: this._upperFirstAll(this.localize(_.trim(_.get(patient, "gender", "male")) + "GenderLong", "masculin")),
                            dateOfBirthHr: this._YYYYMMDDToDDMMYYYY(_.trim(_.get(patient, "dateOfBirth"))),
                            insuranceData: _
                                .chain(_.get(patient, "insurabilities",{}))
                                .filter((i)=>{
                                    return i &&
                                        !!moment( _.trim(_.get(i, "startDate", "0") ), "YYYYMMDD" ).isBefore(moment()) &&
                                        (!!moment( _.trim(_.get(i, "endDate", "0") ), "YYYYMMDD" ).isAfter(moment()) || !_.trim(_.get(i, "endDate", "") ) ) &&
                                        !!_.trim( _.get( i, "insuranceId", "" ) )
                                })
                                .map(i => {return {
                                    insuranceId: _.trim(_.get(i,"insuranceId","")),
                                    identificationNumber: _.trim(_.get(i,"identificationNumber","")),
                                    tc1: _.trim(_.get(i,"parameters.tc1","")),
                                    tc2: _.trim(_.get(i,"parameters.tc2","")),
                                    preferentialstatus: typeof _.get(i,"parameters.preferentialstatus") === "boolean" ? !!_.get(i,"parameters.preferentialstatus",false) : _.trim(_.get(i,"parameters.preferentialstatus")) === "true"
                                }})
                                .head()
                                .value(),
                        })
                    })
                    .then(patient => this._getInsuranceData(_.trim(_.get(patient,"insuranceData.insuranceId"))).then(insuranceData => _.merge({},patient,{insuranceData:insuranceData})))
                    .catch(()=>promResolve)

            }

            _getInsuranceData(insuranceId) {

                const promResolve = Promise.resolve()

                return !_.trim(insuranceId) ? promResolve : this.api.insurance().getInsurance(insuranceId)
                    .then(insuranceData => _.merge({}, {
                        code: _.trim(_.get(insuranceData, "code", "")),
                        name: this._upperFirstAll(!!_.trim(_.get(insuranceData, "name." + this.language, "")) ? _.trim(_.get(insuranceData, "name." + this.language, "")) : _.trim(_.find(_.get(insuranceData, "name", {}), _.trim)))
                    }))
                    .catch(()=>promResolve)

            }

            _getCodesByType(codeType) {

                const promResolve = Promise.resolve()

                return !_.trim(codeType) ? promResolve : this.api.code().findPaginatedCodes("be", codeType)
                    .then(({rows}) => _
                        .chain(rows)
                        .filter(i=> !_.get(i,"disabled",false))
                        .map(i => _.merge({},i,{
                            labelHr:_.trim(_.get(i,"label." + this.language,"")) ?
                                _.upperFirst(_.trim(_.get(i,"label." + this.language,"")).toLowerCase()) :
                                _.upperFirst(_.trim(_.head(_.flatMap(_.get(i,"label","")))).toLowerCase())
                        }))
                        .orderBy(["labelHr"],["asc"])
                        .value()
                    )
                    .then(codes => _.fromPairs([[codeType,codes]]))
                    .catch(()=>promResolve)

            }

            _getContact(user, contactId, patient) {

                const promResolve = Promise.resolve()


                Si contact => prendre tous les contacts ayant le même group ip + pas services vides + order by modified asc, index
                du coup: pas faire via getContactWithUser mais bien via "findBy" comme ci-dessous


                this.api.contact().findBy(_.trim(_.get(user,"healthcarePartyId","")), patient)
                    .then(contacts => {
                        console.log("----------contacts-----------", contacts);
                    })

                _.get(_.find(allContacts, {id:contactId}),"groupId")
                _.filter(allContacts, {groupId:_.get(_.find(allContacts, {id:contactId}),"groupId")})



                return !_.trim(_.get(user, "id")) || !_.trim(contactId) ? promResolve : this.api.contact().getContactWithUser(user, contactId)
                    .then(contact => _.merge(contact, {
                        createdHr: this._msTstampToDDMMYYYY(_.get(contact,"created","")),

                        openingDateHr: this._YYYYMMDDToDDMMYYYY(_.trim(_.get(contact,"openingDate","")).substring(0,8)),
                        openingTimeHr: _.trim(_.get(contact,"openingDate","")).substring(8,10) + ":" + _.trim(_.get(contact,"openingDate","")).substring(10,12) + ":" + _.trim(_.get(contact,"openingDate","")).substring(12,14),
                        openingDateTimeHr: this._YYYYMMDDHHmmssToDDMMYYYYHHmmss(_.get(contact,"openingDate","")),

                        closingDateHr: this._YYYYMMDDToDDMMYYYY(_.trim(_.get(contact,"closingDate","")).substring(0,8)),
                        closingTimeHr: _.trim(_.get(contact,"closingDate","")).substring(8,10) + ":" + _.trim(_.get(contact,"closingDate","")).substring(10,12) + ":" + _.trim(_.get(contact,"closingDate","")).substring(12,14),
                        closingDateTimeHr: this._YYYYMMDDHHmmssToDDMMYYYYHHmmss(_.get(contact,"closingDate","")),
                    }))
                    .catch(()=>promResolve)

            }

            _prettifyDocInfo(docInfo) {

                return !_.size(docInfo) ? null :_.merge({}, docInfo, {
                    demandDateHr: this._msTstampToDDMMYYYY(_.get(docInfo,"demandDate","")),
                    firstName: this._upperFirstAll(_.get(docInfo,"firstName","")),
                    lastName: this._upperFirstAll(_.get(docInfo,"lastName","")),
                    labo: this._upperFirstAll(_.get(docInfo,"labo","")),
                    ssinHr: this.api.formatSsinNumber(_.trim(_.get(docInfo,"ssin",""))),
                    dateOfBirthHr: this._YYYYMMDDToDDMMYYYY(_.trim(_.get(docInfo, "dateOfBirth"))),
                })

            }

            _getDocument(user, documentId) {

                const promResolve = Promise.resolve()

                return !_.trim(documentId) ? promResolve : this.api.document().getDocument(documentId)
                    .then(document => !_.size(_.get(document,"encryptionKeys",[])) && !_.size(_.get(document,"delegations",[])) ?
                        Promise.resolve([document,null]) :
                        this.api.crypto().extractKeysFromDelegationsForHcpHierarchy(_.trim(_.get(user,"healthcarePartyId","")), _.trim(_.get(document,"id","")), _.size(_.get(document,"encryptionKeys",[])) ? _.get(document,"encryptionKeys",[]) : _.get(document,"delegations",[]))
                            .then(({extractedKeys: enckeys}) => ([document,enckeys]))
                            .catch(()=>Promise.resolve([document,null]))
                    )
                    .then(([document,enckeys]) => this.api.beresultimport().canHandle(_.trim(_.get(document,"id","")), (enckeys||[]).join(',')).then(canHandle => ([document,enckeys,!!canHandle])).catch(() => Promise.resolve([document,enckeys,false])))
                    .then(([document,enckeys,canHandle]) => !canHandle ? Promise.resolve([document,enckeys]) : this.api.beresultimport().getInfos(_.trim(_.get(document,"id","")), true, null, (enckeys||[]).join(',')).then(docInfo=>([_.merge({},document,{docInfo:this._prettifyDocInfo(_.head(docInfo))}),enckeys])).catch(() => Promise.resolve([document,enckeys])))
                    .then(([document,enckeys]) => this.api.document().getAttachment(_.trim(_.get(document,"id","")), _.trim(_.get(document,"attachmentId","")), (enckeys||[]).join(',')).then(attachmentContent => _.merge({}, document, {attachment: {content:attachmentContent}})).catch(()=>Promise.resolve(document)))
                    .then(document => {
                        const fileExtension = (_.trim(_.get(document,"name","")).split(".").pop()).toLowerCase()
                        const attachmentSize = _.get((typeof _.get(document,"attachment.content","") === "string" ? this.api.crypto().utils.text2ua(_.get(document,"attachment.content","")) : _.get(document,"attachment.content","")),"byteLength",0)
                        const attachmentSizePow = attachmentSize > (1024**2) ? 2 : attachmentSize > 1024 ? 1 : 0
                        return _.merge({},document,{attachment:{
                            filename: _.kebabCase(_.trim(_.get(document,"name","")).toLowerCase().replace("."+fileExtension,"")) + "." + _.trim(fileExtension),
                            fileExtension: fileExtension,
                            size: this.api._powRoundFloatByPrecision( attachmentSize / (1024**attachmentSizePow) ,2) + " " + _.trim(attachmentSizePow === 2 ? "Mb" : attachmentSizePow === 1 ? "Kb" : "Bytes"),
                            mimeType: _.trim(this.api.document().mimeType(_.trim(_.get(document,"mainUti","")))) ? _.trim(this.api.document().mimeType(_.trim(_.get(document,"mainUti","")))) : "text/plain",
                        }})
                    })
                    .then(document => !_.trim(_.get(document, "docInfo.ssin","")) ?
                        document :
                        this.api.patient().findByNameBirthSsinAutoWithUser(user, _.trim(_.get(user,"healthcarePartyId","")), _.trim(_.get(document, "docInfo.ssin","")), null, null, 10)
                            .then(({rows}) => !_.size(rows) ? document : this._getPrettifiedPatient(null,null,_.chain(rows).filter(i => !!_.get(i,"active",false)).orderBy(["modified"],["desc"]).head().value()).then(patient => _.merge({},document,{docInfo:{patient:patient}})))
                            .catch(()=>Promise.resolve(document))
                    )
                    .catch(()=>promResolve)

            }

            _isServiceOutOfRange(svc) {
                const c = this.api.contact().preferredContent(svc, this.language)
                return (c && c.measureValue && (c.measureValue.value < c.measureValue.min || c.measureValue.value > c.measureValue.max ))
            }

            _getServiceDate(svc) {
                return (svc && svc.modified) ? this.api.moment(svc.modified).format(svc.modified > 99991231 ? 'DD/MM/YYYY HH:mm' : 'DD/MM/YYYY') : '';
            }

            _getContentFromContact(contact) {

                const data = {
                    dateHr: _.get(contact,"openingDateHr",""),
                    timeHr: _.get(contact,"openingTimeHr",""),
                    title: _.get(contact,"descr",""),
                    type: _.get(_.find(_.get(this,"_data.codes.CD-TRANSACTION",[]), {code:_.get(_.find(_.get(contact,"tags",[]),{type:"CD-TRANSACTION"}), "code","")}),"labelHr",""),
                    content: _.size(_.get(contact,"services",[])) === 1 ? this._prettifyText(_.get(contact,"services[0]",{})) : _.map(_.orderBy(_.get(contact,"services",[]),["index"],["asc"]), svc => { return {
                        isOutOfRange: !!this._isServiceOutOfRange(svc),
                        label: _.trim(_.get(svc,"label","")),
                        date: this._getServiceDate(svc),
                        value: this._getServiceShortDescription(svc),
                        normalValue: this._getServiceNormalValues(svc),
                        author: this._getServiceAuthor(svc),
                    }})
                }

                // Could be "descr" also holds CD-TRANSACTION
                data.title = _.trim(data.type) ? _.trim(data.title.replace(data.type+":","")) : data.type

                return data

            }

            printDocument(inputData) {

                const promResolve = Promise.resolve()
                const patientId = _.trim(_.get(inputData,"patientId",_.trim(_.get(this,"patient.id",""))))
                const contactId = _.trim(_.get(inputData,"contactId",""))
                const documentId = _.trim(_.get(inputData,"documentId",""))
                const sourceComponent = _.trim(_.get(inputData,"source",""))
                const ehboxMessageId = _.trim(_.get(inputData,"ehboxMessageId",""))

                // Make sure properties of component (that aren't set yet) actually are a variable rather than an object with a value key representing their value.
                _.map(_.get(this,"_data",{}), (propValue,propKey) => typeof _.get(propValue,"value",null) !== "function" ? null : this.set("_data." + propKey, _.get(propValue,"value",null)()))

                return this._resetComponentProperties()
                    .then(() => this._getPrettifiedHcp().then(hcp => _.assign(this._data, {currentHcp:hcp})))
                    .then(() => this._getPrettifiedPatient(_.get(this,"user",{}), patientId).then(patient => _.assign(this._data, {currentPatient:patient})))
                    .then(() => this._getCodesByType("CD-TRANSACTION").then(codes => _.merge(this._data,{codes:codes})))
                    .then(() => this._getContact(_.get(this,"user",{}), contactId, _.get(this,"_data.currentPatient")).then(contact => _.assign(this._data,{contact:contact})))
                    .then(() => this._getDocument(_.get(this,"user",{}), documentId).then(document => _.assign(this._data,{document:document})))
                    .then(() => (!_.size(_.get(this,"_data.document")) && !_.size(_.get(this,"_data.contact"))) ? null :
                        sourceComponent === "ht-services-list" ? this._getContentFromContact(_.get(this,"_data.contact")) :
                        null
                    )
                    .then(contentData => console.log("----- contentData -----", contentData))
                    .then(() => {
                        console.log("--- this._data ---",this._data);
                        console.log("inputData",inputData);
                    })
                    .catch(e => promResolve)
                    .finally(() => this.dispatchEvent(new CustomEvent('done-printing-document', {composed:true,bubbles:true,detail:{}})) && promResolve)

                    // https://raw.githubusercontent.com/AssossCare/icure-frontend/feature/TOP-Kine-Fab/web/icure-ht/app/src/elements/ht-pat/dialogs/ht-pat-triptyque.html

                    // Get ehboxMessageId (si besoin)

                    // Eval le type d'info à afficher:  ==> ET ne prendre les data / resolve que fonction de ce dont j'ai besoin (pas tout le tralala avec document / contact / ehbox si pas besoin
                    //      Plain
                    //      Labresult => en tant que document
                    //      Labresult => en tant services
                    //      Protocol => en tant document
                    //      Protocol => en tant que service(s)

                    // Si depuis dynamic doc / ehbox : bien se passer languages, ressources, pat, ... tout ce qu iest nécessaire
                    // Si depuis dynamic doc -> on fait de toute façon un DocInfo (full) => on a donc liste des services ici !



                    // this._getPatAndHcpCommonData()
                    //     .then(patAndHcpData => this._getPdfHeader() +
                    //         `<div class="page">` +
                    //         this._getPatientVignetteHtmlCode(patAndHcpData.patientData) +
                    //         "<pre>" + renderedContent + "</pre>" +
                    //         this._getDoctorDetailsHtmlCode(patAndHcpData.hcpData) +
                    //         `</div>` +
                    //         '<'+'script'+'>'+'document.fonts.ready.then(() => { setInterval(() => {document.body.dispatchEvent(new CustomEvent("pdfDoneRenderingEvent"))}, 500); }); <'+'/script'+'>' +
                    //         this._getPdfFooter()
                    //     )
                    //     .then(pdfHtmlContent => this.api.pdfReport(pdfHtmlContent), {type:"unknown",completionEvent:"pdfDoneRenderingEvent"})
                    //     .then(printedPdf => {
                    //         console.log(printedPdf);
                    //         return !printedPdf.printed && this.api.triggerFileDownload( printedPdf.pdf, "application/pdf", "my-download-filename.pdf" )
                    //     })



                    // Print + trigger download
                    // ------------------------

                    // Pouvoir changer date & type doc sur contact
                    // Fuck doimport pour jamoule ? Une ligne only ?






                    // Ensuite edit type document & date d'un contact

                    // [NOUVEAUX DOCUMENTS]
                    //
                    // CTC => tags[] => some type:originalEhBoxMessageId && has id
                    //
                    // [ANCIENS DOCUMENTS] Pour retrouver documents de ehbox:
                    //
                    // CTC => subContacts
                    //     ==> si a protocol
                    //     ==> ou si stats = ....
                    //     ==> Comparer les deux approches
                    //
                    // Status subcontact:
                    //
                    //     public final static int STATUS_LABO_RESULT = 1;
                    // public final static int STATUS_UNREAD = 2;
                    // public final static int STATUS_ALWAYS_DISPLAY = 4;
                    // public final static int RESET_TO_DEFAULT_VALUES = 8;
                    // public final static int STATUS_COMPLETE = 16;
                    // public final static int STATUS_PROTOCOL_RESULT = 32;
                    // public final static int STATUS_UPLOADED_FILES = 64;





            }

        }

        customElements.define(PrintDocument.is, PrintDocument);



    </script>



</dom-module>
